package io.github.anticipasean.ent.state;

import com.oath.cyclops.types.Filters;
import com.oath.cyclops.types.persistent.PersistentMap;
import cyclops.control.Maybe;
import cyclops.control.Option;
import cyclops.control.Try;
import cyclops.data.BankersQueue;
import cyclops.data.DMap.Three;
import cyclops.data.DMap.Two;
import cyclops.data.HashMap;
import cyclops.data.HashSet;
import cyclops.data.ImmutableMap;
import cyclops.data.LazySeq;
import cyclops.data.NonEmptyList;
import cyclops.data.Seq;
import cyclops.data.TreeSet;
import cyclops.data.Vector;
import cyclops.data.tuple.Tuple2;
import cyclops.data.tuple.Tuple3;
import cyclops.function.Function3;
import cyclops.function.Function4;
import cyclops.function.Monoid;
import cyclops.function.Reducer;
import cyclops.reactive.ReactiveSeq;
import io.github.anticipasean.ent.Ent;
import io.github.anticipasean.ent.pattern.ValuePatternttern;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.stream.Collector;

public final class FilledEnt<K, V> implements Ent<K, V> {

    private final ImmutableMap<K, V> data;

    //    protected TreeMap<Key<ID, C>, Attribute<C>> data;

    //    protected static <ID extends Comparable<ID>, C> TreeMap<Key<ID, C>, Attribute<C>> emptyDataMap() {
    ////        return TreeMap.<Key<ID, C>, Attribute<C>>empty(Key.keyComparator());
    //    }


    public FilledEnt(ImmutableMap<K, V> data) {
        this.data = data;
    }

    @Override
    public int size() {
        return data.size();
    }

    @Override
    public <R> Ent<K, R> map(Function<? super V, ? extends R> fn) {
        Objects.requireNonNull(fn,
                               "fn");
        return new FilledEnt<K, R>(data.stream()
                                       .map(tuple -> tuple.map2(fn))
                                       .toHashMap(Tuple2::_1,
                                                   Tuple2::_2));
    }

    @Override
    public <R> Option<R> matchGet(K key,
                                  Pattern<V, R> valuePattern) {
        Objects.requireNonNull(valuePattern,
                               "patternMap");
        return data.get(key)
                   .map(Pattern.mapper(valuePattern));
    }

    @Override
    public <R> Ent<K, R> matchMap(Pattern<V, R> valuePattern) {
        return new FilledEnt<K, R>(data.mapValues(Pattern.mapper(valuePattern))
                                       .toHashMap(Tuple2::_1,
                                                   Tuple2::_2));

    }

    @Override
    public Iterator<Tuple2<K, V>> iterator() {
        return data.iterator();
    }

    @Override
    public boolean allMatch(Predicate<? super Tuple2<K, V>> c) {
        return data.allMatch(c);
    }

    @Override
    public Ent<K, V> put(K key,
                         V value) {
        return new FilledEnt<>(data.put(key,
                                        value));
    }

    @Override
    public Ent<K, V> put(Tuple2<K, V> keyAndValue) {
        return new FilledEnt<>(data.put(keyAndValue));
    }

    @Override
    public Ent<K, V> putAll(PersistentMap<? extends K, ? extends V> map) {
        return new FilledEnt<>(data.putAll(map));
    }

    @Override
    public Ent<K, V> remove(K key) {
        return new FilledEnt<>(data.remove(key));
    }

    @Override
    public Ent<K, V> removeAll(K... keys) {
        return new FilledEnt<>(data.removeAll(keys));
    }

    @Override
    public ReactiveSeq<K> keys() {
        return data.keys();
    }

    @Override
    public ReactiveSeq<V> values() {
        return data.values();
    }

    @Override
    public Ent<K, V> removeAllKeys(Iterable<? extends K> keys) {
        return new FilledEnt<>(data.removeAllKeys(keys));
    }

    @Override
    public boolean containsValue(V value) {
        return data.containsValue(value);
    }

    @Override
    public boolean isEmpty() {
        return data.isEmpty();
    }

    @Override
    public boolean containsKey(K key) {
        return data.containsKey(key);
    }

    @Override
    public boolean contains(Tuple2<K, V> t) {
        return data.contains(t);
    }

    @Override
    public Option<V> get(K key) {
        return data.get(key);
    }

    @Override
    public V getOrElse(K key,
                       V alt) {
        return data.getOrElse(key,
                              alt);
    }

    @Override
    public V getOrElseGet(K key,
                          Supplier<? extends V> alt) {
        return data.getOrElseGet(key,
                                 alt);
    }

    @Override
    public Map<K, V> toMap() {
        return data.javaMap();
    }

    @Override
    public <K1, V1> HashMap<K1, V1> toHashMap(Function<? super Tuple2<K1, V1>, ? extends K1> keyMapper,
                                              Function<? super Tuple2<K1, V1>, ? extends V1> valueMapper) {
        return null;
    }

    @Override
    public <K1, V1> Map<K1, V1> toMap(Function<? super Tuple2<K1, V1>, ? extends K1> keyMapper,
                                      Function<? super Tuple2<K1, V1>, ? extends V1> valueMapper) {
        return null;
    }


    @Override
    public <R> HashMap<R, Tuple2<K, V>> toHashMap(Function<? super Tuple2<K, V>, ? extends R> keyMapper) {
        return null;
    }

    @Override
    public <R> Map<R, Tuple2<K, V>> toMap(Function<? super Tuple2<K, V>, ? extends R> keyMapper) {
        Objects.requireNonNull(keyMapper, "keymapper");
        return data.toMap(keyMapper);
    }

    @Override
    public String mkString() {
        return data.mkString();
    }

    @Override
    public <K2, V2> Two<K, V, K2, V2> merge(ImmutableMap<K2, V2> one) {
        return data.merge(one);
    }

    @Override
    public <K2, V2, K3, V3> Three<K, V, K2, V2, K3, V3> merge(Two<K2, V2, K3, V3> two) {
        return data.merge(two);
    }

    @Override
    public ReactiveSeq<Tuple2<K, V>> stream() {
        return data.stream();
    }

    @Override
    public <R> Ent<K, R> mapValues(Function<? super V, ? extends R> mapper) {
        return map(mapper);
    }

    @Override
    public <R> Ent<R, V> mapKeys(Function<? super K, ? extends R> mapper) {
        return new FilledEnt<>(data.mapKeys(mapper));
    }

    @Override
    public <R1, R2> Ent<R1, R2> bimap(BiFunction<? super K, ? super V, ? extends Tuple2<R1, R2>> map) {
        return new FilledEnt<>(data.bimap(map));
    }

    @Override
    public <K2, V2> Ent<K2, V2> flatMap(BiFunction<? super K, ? super V, ? extends ImmutableMap<K2, V2>> mapper) {
        return new FilledEnt<>(data.flatMap(mapper));
    }

    @Override
    public <K2, V2> Ent<K2, V2> concatMap(BiFunction<? super K, ? super V, ? extends Iterable<Tuple2<K2, V2>>> mapper) {
        return new FilledEnt<>(data.concatMap(mapper));
    }

    @Override
    public Ent<K, V> filter(Predicate<? super Tuple2<K, V>> predicate) {
        return new FilledEnt<>(data.filter(predicate));
    }

    @Override
    public Ent<K, V> filterKeys(Predicate<? super K> predicate) {
        return new FilledEnt<>(data.filterKeys(predicate));
    }

    @Override
    public Ent<K, V> filterValues(Predicate<? super V> predicate) {
        return new FilledEnt<>(data.filterValues(predicate));
    }

    @Override
    public Ent<K, V> filterNot(Predicate<? super Tuple2<K, V>> predicate) {
        return new FilledEnt<>(data.filterNot(predicate));
    }

    @Override
    public Ent<K, V> notNull() {
        return new FilledEnt<>(data.notNull());
    }

    @Override
    public Ent<K, V> peek(Consumer<? super V> c) {
        return new FilledEnt<>(data.peek(c));
    }

    @Override
    public <R1, R2> Ent<R1, R2> bimap(Function<? super K, ? extends R1> fn1,
                                      Function<? super V, ? extends R2> fn2) {
        return new FilledEnt<>(data.bimap(fn1,
                                          fn2));
    }

    @Override
    public Ent<K, V> bipeek(Consumer<? super K> c1,
                            Consumer<? super V> c2) {
        return new FilledEnt<>(data.bipeek(c1,
                                           c2));
    }

    @Override
    public Ent<K, V> bipeek(BiConsumer<? super K, ? super V> peeker) {
        Objects.requireNonNull(peeker,
                               "peeker");
        return bimap((key, v) -> {
            peeker.accept(key,
                          v);
            return Tuple2.of(key,
                             v);
        });
    }

    @Override
    public Ent<K, V> onEmpty(Tuple2<K, V> value) {
        return new FilledEnt<>(data.onEmpty(value));
    }

    @Override
    public Ent<K, V> onEmptyGet(Supplier<? extends Tuple2<K, V>> supplier) {
        return new FilledEnt<>(data.onEmptyGet(supplier));
    }

    @Override
    public <X extends Throwable> Try<Ent<K, V>, X> onEmptyTry(Supplier<? extends X> supplier) {
        return isEmpty() ? Try.failure(supplier.get()) : Try.success(this);
    }

    @Override
    public Ent<K, V> onEmptySwitch(Supplier<? extends Ent<K, V>> supplier) {
        if (isEmpty()) {
            return supplier.get();
        }
        return this;
    }

    @Override
    public <K1, K2, K3, K4, R1, R2, R3, R> ImmutableMap<K4, R> forEach4(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                                        BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Iterable<Tuple2<K2, R2>>> iterable2,
                                                                        Function3<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? extends Iterable<Tuple2<K3, R3>>> iterable3,
                                                                        Function4<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? super Tuple2<K3, R3>, ? extends Tuple2<K4, R>> yieldingFunction) {
        return data.forEach4(iterable1,
                             iterable2,
                             iterable3,
                             yieldingFunction);
    }

    @Override
    public <K1, K2, K3, K4, R1, R2, R3, R> ImmutableMap<K4, R> forEach4(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                                        BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Iterable<Tuple2<K2, R2>>> iterable2,
                                                                        Function3<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? extends Iterable<Tuple2<K3, R3>>> iterable3,
                                                                        Function4<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? super Tuple2<K3, R3>, Boolean> filterFunction,
                                                                        Function4<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? super Tuple2<K3, R3>, ? extends Tuple2<K4, R>> yieldingFunction) {
        return data.forEach4(iterable1,
                             iterable2,
                             iterable3,
                             filterFunction,
                             yieldingFunction);
    }

    @Override
    public <K1, K2, K3, R1, R2, R> ImmutableMap<K3, R> forEach3(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                                BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Iterable<Tuple2<K2, R2>>> iterable2,
                                                                Function3<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? extends Tuple2<K3, R>> yieldingFunction) {
        return data.forEach3(iterable1,
                             iterable2,
                             yieldingFunction);
    }

    @Override
    public <K1, K2, K3, R1, R2, R> ImmutableMap<K3, R> forEach3(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                                BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Iterable<Tuple2<K2, R2>>> iterable2,
                                                                Function3<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, Boolean> filterFunction,
                                                                Function3<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? super Tuple2<K2, R2>, ? extends Tuple2<K3, R>> yieldingFunction) {
        return data.forEach3(iterable1,
                             iterable2,
                             filterFunction,
                             yieldingFunction);
    }

    @Override
    public <K1, K2, R1, R> ImmutableMap<K2, R> forEach2(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                        BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Tuple2<K2, R>> yieldingFunction) {
        return data.forEach2(iterable1,
                             yieldingFunction);
    }

    @Override
    public <K1, K2, R1, R> ImmutableMap<K2, R> forEach2(Function<? super Tuple2<K, V>, ? extends Iterable<Tuple2<K1, R1>>> iterable1,
                                                        BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, Boolean> filterFunction,
                                                        BiFunction<? super Tuple2<K, V>, ? super Tuple2<K1, R1>, ? extends Tuple2<K2, R>> yieldingFunction) {
        return data.forEach2(iterable1,
                             filterFunction,
                             yieldingFunction);
    }

    @Override
    public <T> Seq<T> toSeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn) {
        return data.toSeq(fn);
    }

    @Override
    public <T> LazySeq<T> toLazySeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn) {
        return data.toLazySeq(fn);
    }

    @Override
    public void forEach(Consumer<? super Tuple2<K, V>> action) {
        data.forEach(action);
    }

    @Override
    public Spliterator<Tuple2<K, V>> spliterator() {
        return data.spliterator();
    }

    @Override
    public <R> R[] toArray(IntFunction<R[]> generator) {
        return data.toArray(generator);
    }

    @Override
    public Object[] toArray() {
        return data.toArray();
    }

    @Override
    public <R> R to(Function<? super Iterable<? super Tuple2<K, V>>, ? extends R> fn) {
        return data.iterableTo(fn);
    }

    @Override
    public BankersQueue<Tuple2<K, V>> bankersQueue() {
        return data.bankersQueue();
    }

    @Override
    public TreeSet<Tuple2<K, V>> treeSet(Comparator<? super Tuple2<K, V>> comp) {
        return data.treeSet(comp);
    }

    @Override
    public HashSet<Tuple2<K, V>> hashSet() {
        return data.hashSet();
    }

    @Override
    public Vector<Tuple2<K, V>> vector() {
        return data.vector();
    }

    @Override
    public LazySeq<Tuple2<K, V>> lazySeq() {
        return data.lazySeq();
    }

    @Override
    public Seq<Tuple2<K, V>> seq() {
        return data.seq();
    }

    @Override
    public NonEmptyList<Tuple2<K, V>> nonEmptyList(Supplier<Tuple2<K, V>> s) {
        return data.nonEmptyList(s);
    }


    @Override
    public <T extends Collection<Tuple2<K, V>>> T toCollection(Supplier<T> collectionFactory) {
        return data.toCollection(collectionFactory);
    }

    @Override
    public <R> R collect(Supplier<R> supplier,
                         BiConsumer<R, ? super Tuple2<K, V>> accumulator,
                         BiConsumer<R, R> combiner) {
        return data.collect(supplier,
                            accumulator,
                            combiner);
    }

    @Override
    public List<Tuple2<K, V>> toList() {
        return data.toList();
    }

    @Override
    public Set<Tuple2<K, V>> toSet() {
        return data.toSet();
    }

    @Override
    public <R1, R2, A1, A2> Tuple2<R1, R2> collect(Collector<? super Tuple2<K, V>, A1, R1> c1,
                                                   Collector<? super Tuple2<K, V>, A2, R2> c2) {
        return data.collect(c1,
                            c2);
    }

    @Override
    public <R1, R2, R3, A1, A2, A3> Tuple3<R1, R2, R3> collect(Collector<? super Tuple2<K, V>, A1, R1> c1,
                                                               Collector<? super Tuple2<K, V>, A2, R2> c2,
                                                               Collector<? super Tuple2<K, V>, A3, R3> c3) {
        return data.collect(c1,
                            c2,
                            c3);
    }

    @Override
    public long countDistinct() {
        return data.countDistinct();
    }

    @Override
    public <U> Option<Tuple2<K, V>> maxBy(Function<? super Tuple2<K, V>, ? extends U> function,
                                          Comparator<? super U> comparator) {
        return data.maxBy(function,
                          comparator);
    }

    @Override
    public <U extends Comparable<? super U>> Option<Tuple2<K, V>> maxBy(Function<? super Tuple2<K, V>, ? extends U> function) {
        return data.maxBy(function);
    }

    @Override
    public <U extends Comparable<? super U>> Option<Tuple2<K, V>> minBy(Function<? super Tuple2<K, V>, ? extends U> function) {
        return data.minBy(function);
    }

    @Override
    public <U extends Comparable<? super U>> Option<Tuple2<K, V>> minBy(Function<? super Tuple2<K, V>, ? extends U> function,
                                                                        Comparator<? super U> comparator) {
        return data.minBy(function,
                          comparator);
    }

    @Override
    public Option<Tuple2<K, V>> mode() {
        return data.mode();
    }

    @Override
    public ReactiveSeq<Tuple2<Tuple2<K, V>, Integer>> occurrences() {
        return data.occurances();
    }

    @Override
    public double mean(ToDoubleFunction<Tuple2<K, V>> fn) {
        return data.mean(fn);
    }

    @Override
    public Option<Tuple2<K, V>> median() {
        return data.median();
    }

    @Override
    public Seq<Tuple2<Tuple2<K, V>, BigDecimal>> withPercentiles() {
        return data.withPercentiles();
    }

    @Override
    public Option<Tuple2<K, V>> atPercentile(double percentile) {
        return data.atPercentile(percentile);
    }

    @Override
    public double variance(ToDoubleFunction<Tuple2<K, V>> fn) {
        return data.variance(fn);
    }

    @Override
    public double populationVariance(ToDoubleFunction<Tuple2<K, V>> fn) {
        return data.populationVariance(fn);
    }

    @Override
    public double stdDeviation(ToDoubleFunction<Tuple2<K, V>> fn) {
        return data.stdDeviation(fn);
    }

    @Override
    public Option<Tuple2<K, V>> maximum(Comparator<? super Tuple2<K, V>> comparator) {
        return data.maximum(comparator);
    }

    @Override
    public Option<Tuple2<K, V>> minimum(Comparator<? super Tuple2<K, V>> comparator) {
        return data.minimum(comparator);
    }

    @Override
    public int sumInt(ToIntFunction<Tuple2<K, V>> fn) {
        return data.sumInt(fn);
    }

    @Override
    public double sumDouble(ToDoubleFunction<Tuple2<K, V>> fn) {
        return data.sumDouble(fn);
    }

    @Override
    public long sumLong(ToLongFunction<Tuple2<K, V>> fn) {
        return data.sumLong(fn);
    }

    @Override
    public boolean anyMatch(Predicate<? super Tuple2<K, V>> c) {
        return data.anyMatch(c);
    }

    @Override
    public boolean noneMatch(Predicate<? super Tuple2<K, V>> c) {
        return data.noneMatch(c);
    }

    @Override
    public <R, A> R collect(Collector<? super Tuple2<K, V>, A, R> collector) {
        return data.collect(collector);
    }

    @Override
    public long count() {
        return data.count();
    }

    @Override
    public <R> R foldMap(Reducer<R, Tuple2<K, V>> reducer) {
        return data.foldMap(reducer);
    }

    @Override
    public <R> R foldMap(Function<? super Tuple2<K, V>, ? extends R> mapper,
                         Monoid<R> reducer) {
        return data.foldMap(mapper,
                            reducer);
    }

    @Override
    public Option<Tuple2<K, V>> foldLeft(BinaryOperator<Tuple2<K, V>> accumulator) {
        return data.foldLeft(accumulator);
    }

    @Override
    public <U> U foldLeft(U identity,
                          BiFunction<U, ? super Tuple2<K, V>, U> accumulator) {
        return data.foldLeft(identity,
                             accumulator);
    }

    @Override
    public <U> U foldLeft(U identity,
                          BiFunction<U, ? super Tuple2<K, V>, U> accumulator,
                          BinaryOperator<U> combiner) {
        return data.foldLeft(identity,
                             accumulator,
                             combiner);
    }

    @Override
    public Tuple2<K, V> foldLeft(Tuple2<K, V> identity,
                                 BinaryOperator<Tuple2<K, V>> accumulator) {
        return data.foldLeft(identity,
                             accumulator);
    }

    @Override
    public Tuple2<K, V> foldLeft(Monoid<Tuple2<K, V>> reducer) {
        return data.foldLeft(reducer);
    }

    @Override
    public Seq<Tuple2<K, V>> foldLeft(Iterable<? extends Monoid<Tuple2<K, V>>> reducers) {
        return data.foldLeft(reducers);
    }

    @Override
    public Tuple2<K, V> foldRight(Monoid<Tuple2<K, V>> reducer) {
        return data.foldRight(reducer);
    }

    @Override
    public Tuple2<K, V> foldRight(Tuple2<K, V> identity,
                                  BinaryOperator<Tuple2<K, V>> accumulator) {
        return data.foldRight(identity,
                              accumulator);
    }

    @Override
    public <U> U foldRight(U identity,
                           BiFunction<? super Tuple2<K, V>, ? super U, ? extends U> accumulator) {
        return data.foldRight(identity,
                              accumulator);
    }

    @Override
    public <R> R foldMapRight(Reducer<R, Tuple2<K, V>> reducer) {
        return data.foldMapRight(reducer);
    }

    @Override
    public String join() {
        return data.join();
    }

    @Override
    public String join(String sep) {
        return data.join(sep);
    }

    @Override
    public String join(String sep,
                       String start,
                       String end) {
        return data.join(sep,
                         start,
                         end);
    }

    @Override
    public <R> HashMap<R, Vector<Tuple2<K, V>>> groupBy(Function<? super Tuple2<K, V>, ? extends R> classifier) {
        return data.groupBy(classifier);
    }

    @Override
    public Option<Tuple2<K, V>> headOption() {
        return data.headOption();
    }

    @Override
    public boolean startsWith(Iterable<Tuple2<K, V>> iterable) {
        return data.startsWith(iterable);
    }

    @Override
    public boolean endsWith(Iterable<Tuple2<K, V>> iterable) {
        return data.endsWith(iterable);
    }

    @Override
    public Tuple2<K, V> firstValue(Tuple2<K, V> alt) {
        return data.firstValue(alt);
    }

    @Override
    public Tuple2<K, V> singleOrElse(Tuple2<K, V> alt) {
        return data.singleOrElse(alt);
    }

    @Override
    public Maybe<Tuple2<K, V>> single(Predicate<? super Tuple2<K, V>> predicate) {
        return data.single(predicate);
    }

    @Override
    public Maybe<Tuple2<K, V>> single() {
        return data.single();
    }

    @Override
    public Maybe<Tuple2<K, V>> takeOne() {
        return data.takeOne();
    }

    @Override
    public Maybe<Tuple2<K, V>> elementAt(long index) {
        return data.elementAt(index);
    }

    @Override
    public Maybe<Long> indexOf(Predicate<? super Tuple2<K, V>> pred) {
        return data.indexOf(pred);
    }

    @Override
    public Maybe<Long> lastIndexOf(Predicate<? super Tuple2<K, V>> pred) {
        return data.lastIndexOf(pred);
    }

    @Override
    public Maybe<Long> indexOfSlice(Iterable<? extends Tuple2<K, V>> slice) {
        return data.indexOfSlice(slice);
    }

    @Override
    public Maybe<Long> lastIndexOfSlice(Iterable<? extends Tuple2<K, V>> slice) {
        return data.lastIndexOfSlice(slice);
    }


    @Override
    public boolean atLeast(int num,
                           Predicate<? super Tuple2<K, V>> c) {
        return data.atLeast(num,
                            c);
    }

    @Override
    public boolean atMost(int num,
                          Predicate<? super Tuple2<K, V>> c) {
        return data.atMost(num,
                           c);
    }

    @Override
    public <U> Filters<U> ofType(Class<? extends U> type) {
        return data.ofType(type);
    }
}
